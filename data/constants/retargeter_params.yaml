# CPU or CUDA
# Default: CUDA
# Effect: CUDA only available in certain environments
device: cuda

# Adam and RMSProp
# Default: RMSProp
# Effect: Different types of optimization methods for ML
# You can select another from here https://pytorch.org/docs/stable/optim.html#algorithms but you will need to change the code in retargeter.py
optimizer: RMSprop

# Default: 2.5
# Effect: How fast the gradient descent runs down-hill. Too low and it will take forever to converge, too high and it will overshoot
learning_rate: 2.5

# Default 3
# Effect: How many times the retargeter will try to optimize the hand model
# The higher the number, the more accurate the hand model will be but also the more computation
opt_steps: 2

# Default: 0.71
# Effect: The weight scaling for coupled joints
coupled_scale: 0.71

# A keyvector is a distance between two points in the hand. The retargeter tries to mimic this distance from the mano model into the hand model.
# For example if we touch the pinky to the thumb, pinky2thumb is very small in the mano, so the retargeter will try its best to make pinky2thumb small in the hand model.
# More keyvectors = truer movements but also more computation
# If you want to add keyvectors that are not related to fingertips or palms, modify the code in retargeter.py and retarget_utils.py
keyvectors: [palm2thumb,
            palm2index,
            palm2middle,
            palm2ring,
            palm2pinky,
            thumb2index,
            thumb2middle,
            thumb2ring,
            thumb2pinky,
            index2middle,
            index2ring,
            index2pinky,
            middle2ring,
            middle2pinky,
            ring2pinky,
            pinky2ring_mp,
            ring2middle_mp,
            middle2index_mp,
            ]

# Default: 5.0
# The loss coefficient for each keyvector.
# The  individual coefficient is multiplied by the keyvector error and added to the total loss
# The higher the coefficient, the higher the impact of the keyvector
loss_coeffs:
  palm2thumb: 5.0
  palm2index: 5.0
  palm2middle: 5.0
  palm2ring: 5.0
  palm2pinky: 5.0
  thumb2index: 5.0
  thumb2middle: 5.0
  thumb2ring: 5.0
  thumb2pinky: 5.0
  index2middle: 5.0
  index2ring: 5.0
  index2pinky: 5.0
  middle2ring: 5.0
  middle2pinky: 5.0
  ring2pinky: 5.0
  pinky2ring_mp: 5.0
  ring2middle_mp: 5.0
  middle2index_mp: 5.0

# Default: False
# Effect: If true, the loss coefficient will use the normalized distance between mano keyvector and hand keyvector
# I think they are either all true or all false, but in the original code palm2thumb was always false even if use_scalar_distance was true
use_scalar_distance:
  palm2thumb: False
  palm2index: False
  palm2middle: False
  palm2ring: False
  palm2pinky: False
  thumb2index: False
  thumb2middle: False
  thumb2ring: False
  thumb2pinky: False
  index2middle: False
  index2ring: False
  index2pinky: False
  middle2ring: False
  middle2pinky: False
  ring2pinky: False
  pinky2ring_mp: False
  ring2middle_mp: False
  middle2index_mp: False

# In degrees, do not change order
# Effect: Self-explanatory
joint_ranges:
  THUMB_MCP: [0.0, 130.0]
  THUMB_ABD: [0.0, 85.0]
  THUMB_PIP: [0.0, 180.0]
  THUMB_DIP: [0.0, 180.0]

  INDEX_ABD: [-15.0, 15.0]
  INDEX_MCP: [0.0, 180.0]
  INDEX_PIP: [0.0, 180.0]

  MIDDLE_ABD: [-15.0, 15.0]
  MIDDLE_MCP: [0.0, 180.0]
  MIDDLE_PIP: [0.0, 180.0]

  RING_ABD: [-15.0, 15.0]
  RING_MCP: [0.0, 180.0]
  RING_PIP: [0.0, 180.0]

  PINKY_ABD: [-15.0, 15.0]
  PINKY_MCP: [0.0, 180.0]
  PINKY_PIP: [0.0, 180.0]

mano_shift: [0.0, 0.4, 0.0]
